<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端技术架构]]></title>
    <url>%2F2020%2F09%2F28%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[持续更新中…]]></content>
      <categories>
        <category>frontend</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ionic4开发备忘]]></title>
    <url>%2F2019%2F12%2F20%2FIonic4%E5%BC%80%E5%8F%91%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[Ionic是一款跨平台开发App的框架，详细介绍见官网：https://ionicframework.com 环境搭建全局安装NodeJS和Ionic最新稳定版，安装命令如下： 1npm i -g cordova ionic 新建项目初始化项目命令如下： 1ionic start myIonicApp tabs 其中的tabs为初始化项目模板，可选模板有blank,tabs,sidemenu,tutorial等，可以运行ionic start –list命令查看所有可用模板。 项目常用命令详细命令参考官网：https://ionicframework.com/docs/cli 启动项目 ng serve -o 编译项目 123456ionic cordova prepare iosionic cordova prepare androidionic cordova run android --prod --releaseionic cordova run ios --prod --releaseionic cordova build android --prod --releaseionic cordova build ios --prod --release 管理平台 添加平台： 1ionic cordova platform add android 删除平台：1cordova platform rm ios 根据配置文件安装平台：1cordova prepare 管理插件 添加插件： 1ionic cordova plugin add cordova-sqlite-storage 删除插件：1ionic cordova plugin rm cordova-sqlite-storage 根据配置文件安装插件：cordova prepare 自动创建代码命令1ionic generate page pages/my-page 路由传参路由传参只能传递字符串参数，不能为复杂对象，当然也可以将复杂对象转成json再通过路由进行传参，但这种方式不被推荐，某些情况下转换的对象json中存在特殊字符的话会直接影响路由功能。 前端有localStorage这个比较强大的前端缓存工具，因为路由传参不适合传递复杂对象，我们还有一种方式就是将复杂对象存储在localStorage中，它的key放在路由参数中进行传递，然后到详情页面中通过这个key从localStorage中查询。显然，某些场景下也会出现下面的问题，但这的确是一个方法。关键前端缓存这块后面弄个专题说一下。 在大部分场景中，比如查看订单列表中某一条数据的详细信息，通过路由传递一个id字段到详情页面就足够了，虽然前端可以缓存订单列表中已有的订单字段，但为了数据的准确性，这里还是推荐在详情页面根据id重新获取最新的详情数据。当然，得结合实际业务功能决定到底用何种方式。 路由配置代码： 123const routes: Routes = [ &#123;path: &apos;order-detail/:id&apos;, loadChildren: &apos;./pages/order-detail/order-detail.module#OrderDetailPageModule&apos;&#125;]; 传递参数代码：1&lt;ion-item routerLink=&quot;/order-detail/3&quot;&gt;&lt;/ion-item&gt; 接收参数代码：12345constructor(private route: ActivatedRoute) &#123;&#125;ngOnInit() &#123; const id = this.route.snapshot.paramMap.get(&apos;id&apos;);&#125; 组件传参这里的组件传参就可以直接传递复杂参数，当然它同样不适合上面我们所说的查看详情等场景，但在以下场景中它将为我们带来极大的方便。 涉及到流程表单的场景：用户在前端需要操作一个流程表单，分好几步，第一步干嘛，第二步干嘛，每一步都会在前端录入一些必要数据，而且这些数据可能在下一步的表单操作中要使用到，此时，组件传参就发挥了它的威力。 在使用该component的module中需要配置entryComponents，代码如下： 1234@NgModule(&#123; declarations: [ReceiveOrderPage], entryComponents: [ReceiveOrderPage]&#125;) 在传递参数的component中代码如下：123456789101112constructor(private modalCtrl: ModalController) &#123;&#125;async receiveOrder() &#123; const modal = await this.modalCtrl.create(&#123; component: ReceiveOrderPage, componentProps: &#123; params: &#123;id: 1, name: &apos;hllinc&apos;&#125; &#125;, animated: true &#125;); return await modal.present();&#125; 接收参数代码：123456export class ReceiveOrderPage implements OnInit &#123; @Input() params;&#125;&lt;ion-content padding&gt; &lt;p&gt;&#123;&#123;params.name&#125;&#125;&lt;/p&gt;&lt;/ion-content&gt; 禁用菜单当我们使用menu功能时，一般会在全局添加menu左或右滑动唤出的功能，但在某些场景下，我们只希望在主页面中启用该功能，在子页面中禁用该功能，因为左右滑动在子页面可能会实现其他必要功能，此时我们需要在子页面中添加如下代码以禁用菜单唤出功能，代码如下： 12345constructor(private menuCtrl: MenuController) &#123;&#125;ionViewWillEnter() &#123; this.menuCtrl.enable(false);&#125; Flex布局某些情况下，采用Flex可以为布局带来更好的效果，css代码如下： 123456789101112131415161718.dayPlat &#123;display: flex;flex-wrap: wrap;flex-direction: row;align-content: flex-start;.day &#123; font-size: 14px; width: 60px; height: 60px; text-align: center; line-height: 60px; margin: 10px; border: 1px solid #dddddd; color: #555; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px;&#125; 效果如下图所示： Modal窗口对于一些页面的打开方式我们可能不需要像普通页面那样具有返回功能，在打开的页面中提供一个关闭按钮，并且打开效果也不像普通页面那样从右向左滑入，而是具有弹出效果的打开，以达到提醒用户当前打开页面中的内容很重要的目的。比如，协议页面、登录/注册页面等。 打开Modal窗口，代码如下： 12345678constructor(private modalCtrl: ModalController) &#123;&#125;async openProtocol() &#123; const modal = await this.modalCtrl.create(&#123; component: ProtocolPage &#125;); return await modal.present();&#125; 关闭Modal窗口需要在打开的component中添加如下代码：1234567&lt;ion-button color=&quot;primary&quot; (click)=&quot;closeModal()&quot;&gt; &lt;ion-icon name=&quot;close&quot; color=&quot;light&quot;&gt;&lt;/ion-icon&gt;&lt;/ion-button&gt;constructor(private modalCtrl: ModalController) &#123; &#125;closeModal() &#123; this.modalCtrl.dismiss();&#125; 当然，这个modal中的component也是可以进行传参的，方式同组件传参。 拍照脚本代码如下： 123456789101112131415161718192021222324252627282930import &#123;Component, OnInit&#125; from &apos;@angular/core&apos;;import &#123;Camera, CameraOptions&#125; from &apos;@ionic-native/camera/ngx&apos;;@Component(&#123; selector: &apos;app-camera&apos;, templateUrl: &apos;./camera.page.html&apos;, styleUrls: [&apos;./camera.page.scss&apos;],&#125;)export class CameraPage implements OnInit &#123; imageData; constructor(private camera: Camera) &#123; &#125; ngOnInit() &#123; &#125; takePhone() &#123; const options: CameraOptions = &#123; quality: 100, destinationType: this.camera.DestinationType.DATA_URL, encodingType: this.camera.EncodingType.JPEG, mediaType: this.camera.MediaType.PICTURE &#125;; this.camera.getPicture(options).then((imageData) =&gt; &#123; // imageData is either a base64 encoded string or a file URI // If it&apos;s base64 (DATA_URL) let base64Image = &apos;data:image/jpeg;base64,&apos; + imageData; this.imageData = base64Image; &#125;, (err) =&gt; &#123; // Handle error &#125;); &#125;&#125; 视图代码如下：123456789101112&lt;ion-header&gt; &lt;ion-toolbar&gt; &lt;ion-buttons slot=&quot;start&quot;&gt; &lt;ion-back-button [text]=&quot;&apos;返回&apos;&quot;&gt;&lt;/ion-back-button&gt; &lt;/ion-buttons&gt; &lt;ion-title&gt;camera&lt;/ion-title&gt; &lt;/ion-toolbar&gt;&lt;/ion-header&gt;&lt;ion-content padding&gt; &lt;ion-button (click)=&quot;takePhone()&quot;&gt;拍照&lt;/ion-button&gt; &lt;ion-img [src]=&quot;imageData&quot;&gt;&lt;/ion-img&gt;&lt;/ion-content&gt; 生命周期Ionic4中的生命周期函数和angualr7基本是一样的，下面我们看看Ionic4中的生命周期函数，以及生命周期函数的用法。 Ionic4中内置的生命周期函数： ionViewWillEnter —当进入一个页面时触发(如果它从堆栈返回) ionViewDidEnter —进入后触发 ionViewWillLeave —如果页面将离开触发 ionViewDidLeave — 在页面离开后触发 ionViewWillUnload — 在Angular中没有触发，因为这里你必须使用ngOnDestroy Ionic4中使用Angular生命周期函数： 1、Ionic4中的生命周期函数ngOnChanges 当被绑定的输入属性的值发生变化时调用(父子组件传值的时候会触发) 2、Ionic4中的生命周期函数ngOnInit 请求数据一般放在这个里面 （重要*） 3、Ionic4中的生命周期函数ngDoCheck 检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应 4、Ionic4中的生命周期函数 ngAfterContentInit 当把内容投影进组件之后调用 5、Ionic4中的生命周期函数 ngAfterContentChecked 每次完成被投影组件内容的变更检测之后调用 6、Ionic4中的生命周期函数 ngAfterViewInit 初始化完组件视图及其子视图之后调用（dom操作放在这个里面） （重要） 7、Ionic4中的生命周期函数 ngAfterViewInit 每次做完组件视图和子视图的变更检测之后调用 8、Ionic4中的生命周期函数 ngOnDestroy 组件销毁后执行 （重要） 12345678910111213141516171819202122232425262728293031323334constructor() &#123; console.log(&apos;00构造函数执行了---除了使用简单的值对局部变量进行初始化之外，什么都不应该做&apos;)&#125;ngOnChanges() &#123; console.log(&apos;01ngOnChages执行了---当被绑定的输入属性的值发生变化时调用(父子组件传值的时候会触发)&apos;); &#125;ngOnInit() &#123; console.log(&apos;02ngOnInit执行了--- 请求数据一般放在这个里面&apos;); &#125;ngDoCheck() &#123; //写一些自定义的操作 console.log(&apos;03ngDoCheck执行了---检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应&apos;); if(this.userinfo!==this.oldUserinfo)&#123; console.log(`你从$&#123;this.oldUserinfo&#125;改成$&#123;this.userinfo&#125;`); this.oldUserinfo = this.userinfo; &#125;else&#123; console.log(&quot;数据没有变化&quot;); &#125;&#125;ngAfterContentInit() &#123; console.log(&apos;04ngAfterContentInit执行了---当把内容投影进组件之后调用&apos;);&#125;ngAfterContentChecked() &#123; console.log(&apos;05ngAfterContentChecked执行了---每次完成被投影组件内容的变更检测之后调用&apos;);&#125;ngAfterViewInit(): void &#123; console.log(&apos;06 ngAfterViewInit执行了----初始化完组件视图及其子视图之后调用（dom操作放在这个里面）&apos;);&#125;ngAfterViewChecked() &#123; console.log(&apos;07ngAfterViewChecked执行了----每次做完组件视图和子视图的变更检测之后调用&apos;);&#125;ngOnDestroy() &#123; console.log(&apos;08ngOnDestroy执行了····&apos;);&#125; Ionic4内置生命周期函数使用demo123456789101112export class Page01 implements OnInit &#123; constructor() &#123; &#125; ngOnInit() &#123; &#125; ionViewWillEnter()&#123; console.log(&apos;ionViewWillEnter&apos;); &#125; ionViewDidEnter()&#123; console.log(&apos;ionViewDidEnter&apos;); &#125;&#125; 注：本章节内容转载自网络：http://www.ionic.wang/article-index-id-169.html 地图集成高德地图。 修改应用图标 命令 123ionic cordova resourcesionic cordova resources --iconionic cordova resources --splash 准备 准备一张大小为1024*1024的图片文件作为APP的图标（命名：icon） 准备一张大小为2732 2732(ionic2为2208 2208)的图片作为APP的启动界面（命名：splash） 两张图片的格式为png、psd或ai都可 修改方法 1.将准备好的两张图片（注意分辨率和图片格式）替换到web-app目录下的resources文件夹下。 2.执行ionic cordova resources命令，或分别执行ionic cordova resources –icon和ionic cordova resources –splash。 说明 一般执行第一条命令（ionic cordova resources）即可，如失败（一般都是网络问题，有的是图片问题），网络问题：执行后第二、三条命令（ionic cordova resources –icon和ionic cordova resources –splash），图片问题：修改或更换图片。 如果在启动界面不显示“小圆圈”（进度圈），修改config.xml文件的value为false，为true为显示。如下图： 其他 config.xml配置说明： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;preference name=&quot;webviewbounce&quot; value=&quot;false&quot; /&gt;&lt;preference name=&quot;UIWebViewBounce&quot; value=&quot;false&quot; /&gt;&lt;preference name=&quot;DisallowOverscroll&quot; value=&quot;true&quot; /&gt;&lt;preference name=&quot;android-minSdkVersion&quot; value=&quot;16&quot; /&gt;&lt;preference name=&quot;BackupWebStorage&quot; value=&quot;none&quot; /&gt;&lt;preference name=&quot;ShowSplashScreen&quot; value=&quot;true&quot; /&gt;&lt;preference name=&quot;AutoHideSplashScreen&quot; value=&quot;false&quot; /&gt;&lt;preference name=&quot;ShowSplashScreenSpinner&quot; value=&quot;false&quot; /&gt;&lt;preference name=&quot;SplashMaintainAspectRatio&quot; value=&quot;true&quot; /&gt;&lt;preference name=&quot;FadeSplashScreenDuration&quot; value=&quot;300&quot; /&gt;&lt;preference name=&quot;SplashShowOnlyFirstTime&quot; value=&quot;false&quot; /&gt;&lt;preference name=&quot;SplashScreen&quot; value=&quot;screen&quot; /&gt;&lt;preference name=&quot;SplashScreenDelay&quot; value=&quot;1500&quot; /&gt;&lt;preference name=&quot;Fullscreen&quot; value=&quot;true&quot; /&gt;&lt;preference name=&quot;Orientation&quot; value=&quot;landscape&quot; /&gt;&lt;preference name=&quot;android-minSdkVersion&quot; value=&quot;16&quot; /&gt; android最小sdk版本 &lt;preference name=&quot;BackupWebStorage&quot; value=&quot;none&quot; /&gt; 网络备份存储 &lt;preference name=&quot;ShowSplashScreen&quot; value=&quot;true&quot; /&gt; 显示启动界面 &lt;preference name=&quot;AutoHideSplashScreen&quot; value=&quot;false&quot; /&gt; 自动隐藏启动界面 &lt;preference name=&quot;ShowSplashScreenSpinner&quot; value=&quot;false&quot; /&gt; 显示启动界面的进度圈 &lt;preference name=&quot;SplashMaintainAspectRatio&quot; value=&quot;true&quot; /&gt; 屏幕保持长宽比 &lt;preference name=&quot;FadeSplashScreenDuration&quot; value=&quot;300&quot; /&gt; 启动界面消失延迟 &lt;preference name=&quot;SplashShowOnlyFirstTime&quot; value=&quot;false&quot; /&gt; 启动界面只在第一次显示 &lt;preference name=&quot;SplashScreen&quot; value=&quot;screen&quot; /&gt; 启动界面 &lt;preference name=&quot;SplashScreenDelay&quot; value=&quot;1500&quot; /&gt; 启动界面延迟 &lt;preference name=&quot;Fullscreen&quot; value=&quot;false&quot; /&gt; 全屏显示 &lt;preference name=&quot;Orientation&quot; value=&quot;landscape&quot; /&gt; 屏幕方向。Orientation设置可以让你锁定应用程序屏幕方向以阻止屏幕自动翻转。可选的值有：default，landscape(横屏)，portrait(竖屏)。]]></content>
      <tags>
        <tag>ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript前端对象数组排序核心方法（支持多列排序）]]></title>
    <url>%2F2019%2F06%2F05%2FJavaScript%E5%89%8D%E7%AB%AF%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%EF%BC%88%E6%94%AF%E6%8C%81%E5%A4%9A%E5%88%97%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[开箱即用工具代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 缓存当前数据var tempDataArray = [&#123;name:"linc",age:28&#125;,&#123;name:"linda",age:26&#125;];// 存储排序后的数据var currentData = [];// 排序数组，支持多列排序var orderArr = [&#123;colName:"name",orderDir:"desc"&#125;];// 生成排序脚本var sortData = _generateByStr(orderArr);currentData = tempDataArray.concat();currentData.sort(eval(sortData));// 生成多列排序字符串方法function _generateByStr(tempDataArray) &#123; var arr = tempDataArray.concat(); if (arr == null || arr.length == 0) &#123; return ""; &#125; else &#123; if (arr.length &gt; 1) &#123; var a = arr[0]; arr.shift(); return "_sortBy('" + a.colName + "','" + a.orderDir + "'," + _generateByStr(arr) + ")"; &#125; else &#123; return "_sortBy('" + arr[0].colName + "','" + arr[0].orderDir + "')"; &#125; &#125;&#125;// 排序主方法function _sortBy(name, dir, minor) &#123; return function(o, p) &#123; var a, b; if (o &amp;&amp; p &amp;&amp; typeof o === 'object' &amp;&amp; typeof p === 'object') &#123; a = o[name]; b = p[name]; if (a === b) &#123; return typeof minor === 'function' ? minor(o, p) : 0; &#125; if (typeof a === typeof b) &#123; if (dir == "asc") &#123; return a &lt; b ? -1 : 1; &#125; else &#123; return a &gt; b ? -1 : 1; &#125; &#125; if (dir == "desc") &#123; return typeof a &lt; typeof b ? -1 : 1; &#125; else &#123; return typeof a &gt; typeof b ? -1 : 1; &#125; &#125; else &#123; throw("error"); &#125; &#125;;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后端分离]]></title>
    <url>%2F2019%2F05%2F09%2F%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[代码管理方式开发配合方式部署方式]]></content>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC整合WebSocket]]></title>
    <url>%2F2015%2F10%2F13%2FSpringMVC%E6%95%B4%E5%90%88WebSocket%2F</url>
    <content type="text"><![CDATA[Spring4已经加入了对Websocket支持。 引入Spring4的jar包，以及Spring websocket的jar包 web.xml文件用3.0版本。 1234567&lt; web-app xmlns:xsi= “http://www.w3.org/2001/XMLSchema-instance” xmlns= “http://java.sun.com/xml/ns/javaee” xmlns:web= “http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd” xsi:schemaLocation= “http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd” version= “3.0” &gt; Tomcat用7或以上，JDK用7或以上，其他Spring配置文件按默认即可，这里用的是注解方式。 WebSocketConfig.java 123456789101112131415161718192021222324package com.noter.websocket.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.socket.WebSocketHandler;import org.springframework.web.socket.config.annotation.EnableWebSocket;import org.springframework.web.socket.config.annotation.WebSocketConfigurer;import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;import com.noter.websocket.handler.SystemWebSocketHandler;@Configuration@EnableWebMvc@EnableWebSocketpublic class WebSocketConfig extends WebMvcConfigurerAdapter implements WebSocketConfigurer &#123; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; registry.addHandler(systemWebSocketHandler(), “/webSocketServer.do” ); &#125; @Bean public WebSocketHandler systemWebSocketHandler() &#123; return new SystemWebSocketHandler(); &#125;&#125; SystemWebSocketHandler.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.noter.websocket.handler;import java.io.IOException;import java.util.ArrayList;import org.springframework.web.socket.CloseStatus;import org.springframework.web.socket.TextMessage;import org.springframework.web.socket.WebSocketHandler;import org.springframework.web.socket.WebSocketMessage;import org.springframework.web.socket.WebSocketSession;public class SystemWebSocketHandler implements WebSocketHandler &#123; private static final ArrayList&lt;WebSocketSession&gt; users = new ArrayList&lt;WebSocketSession&gt;();; @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123; System. out.println( “ConnectionEstablished” ); users.add(session); &#125; @Override public void handleMessage(WebSocketSession session, WebSocketMessage&lt;?&gt; message) throws Exception &#123; System. out.println( “session id:” + session.getId()); sendMessageToUsers(session.getId(),(TextMessage) message); &#125; @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; if(session.isOpen())&#123; session.close(); &#125; users.remove(session); &#125; @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception &#123; users.remove(session); &#125; @Override public boolean supportsPartialMessages() &#123; return false; &#125; /** * 给所有在线用户发送消息 * * @param message */ public void sendMessageToUsers(String excep, TextMessage message) &#123; for (WebSocketSession user : users) &#123; try &#123; if (user.isOpen()&amp;&amp; !user.getId().equals(excep)) &#123; user.sendMessage(message); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 前台JSP代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;%@ page language = “java” contentType= “text/html; charset=UTF-8” pageEncoding= “UTF-8” %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + “://” + request.getServerName() + “:” + request.getServerPort() + path + “/”;%&gt;&lt;! DOCTYPE html PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “http://www.w3.org/TR/html4/loose.dtd” &gt;&lt; html&gt;&lt; head&gt;&lt; meta http-equiv= “Content-Type” content = “text/html; charset=UTF-8”&gt;&lt; title&gt; WebSocket/SockJS Echo Sample (Adapted from Tomcat’s echo sample)&lt;/ title&gt; &lt;style type = “text/css”&gt; #connect-container &#123; float: left; width: 400px &#125; #connect-container div &#123; padding: 5px; &#125; #console-container &#123; float: left; margin-left: 15px; width: 400px; &#125; #console &#123; border: 1px solid #CCCCCC ; border-right-color: #999999; border-bottom-color: #999999; height: 170px; overflow-y: scroll; padding: 5px; width: 100%; &#125; #console p &#123; padding: 0; margin: 0; &#125; &lt;/style &gt; &lt;script src = “../assets/js/sockjs-0.3.min.js”&gt;&lt;/ script &gt; &lt;script type = “text/javascript”&gt; var ws = null; var url = null; var transports = []; var basePath = “ &lt;%= basePath%&gt; “; var wsPath = basePath.replace( “http://”, “ws://” ); function setConnected(connected) &#123; document.getElementById( ‘connect’ ).disabled = connected; document.getElementById( ‘disconnect’ ).disabled = !connected; document.getElementById( ‘echo’ ).disabled = !connected; &#125; function connect() &#123; if (!url) &#123; alert( ‘Select whether to use W3C WebSocket or SockJS’); return ; &#125; ws = new WebSocket(wsPath+‘webSocketServer.do’ ); /* (url.indexOf(‘sockjs’) != -1) ? new SockJS(url, undefined, &#123;protocols_whitelist: transports&#125;) : */ ws.onopen = function () &#123; setConnected( true ); log( ‘Info: connection opened.’ ); &#125;; ws.onmessage = function (event) &#123; for ( var i in event.originalTarget)&#123; console.log( “event[“ +i+“]:” +event.originalTarget[i]); &#125; log( ‘Received: ‘ + event.data); &#125;; ws.onclose = function (event) &#123; setConnected( false ); log( ‘Info: connection closed.’ ); log(event); &#125;; &#125; function disconnect() &#123; if (ws != null) &#123; ws.close(); ws = null ; &#125; setConnected( false ); &#125; function echo() &#123; if (ws != null) &#123; var message = document.getElementById(‘message’ ).value; log( ‘Sent: ‘ + message); ws.send(message); &#125; else &#123; alert( ‘connection not established, please connect.’); &#125; &#125; function updateUrl(urlPath) &#123; if (urlPath.indexOf(‘sockjs’ ) != -1) &#123; url = urlPath; document.getElementById(‘sockJsTransportSelect’ ).style.visibility = ‘visible’; &#125; else &#123; if (window.location.protocol == ‘http:’) &#123; url = ‘ws://’ + window.location.host + urlPath; &#125; else &#123; url = ‘wss://’ + window.location.host + urlPath; &#125; document.getElementById(‘sockJsTransportSelect’ ).style.visibility = ‘hidden’; &#125; &#125; function updateTransport(transport) &#123; transports = (transport == ‘all’ ) ? [] : [transport]; &#125; function log(message) &#123; var console = document.getElementById( ‘console’); var p = document.createElement( ‘p’); p.style.wordWrap = ‘break-word’ ; p.appendChild(document.createTextNode(message)); console.appendChild(p); while (console.childNodes.length &gt; 25) &#123; console.removeChild(console.firstChild); &#125; console.scrollTop = console.scrollHeight; &#125; &lt;/script &gt;&lt;/ head&gt;&lt; body&gt;&lt; noscript&gt;&lt; h2 style=” color: #ff0000“ &gt;Seems your browser doesn’t support Javascript! Websockets rely on Javascript being enabled. Please enable Javascript and reload this page!&lt;/ h2&gt;&lt;/ noscript &gt;&lt; div&gt; &lt;div id = “connect-container”&gt; &lt;input id = “radio1” type= “radio” name= “group1” onclick =“updateUrl(‘ $&#123;contextPath&#125; /webSocketServer’);”&gt; &lt;label for = “radio1”&gt; W3C WebSocket&lt;/ label &gt; &lt;br &gt; &lt;input id = “radio2” type= “radio” name= “group1” onclick =“updateUrl(‘/spring-websocket-test/sockjs/echo’);” &gt; &lt;label for = “radio2”&gt; SockJS&lt;/ label &gt; &lt;div id = “sockJsTransportSelect” style=” visibility: hidden;” &gt; &lt;span &gt;SockJS transport: &lt;/ span&gt; &lt;select onchange =“updateTransport(this.value)” &gt; &lt;option value = “all”&gt; all&lt;/ option &gt; &lt;option value = “websocket”&gt; websocket&lt;/ option &gt; &lt;option value = “xhr-polling”&gt; xhr-polling &lt;/option &gt; &lt;option value= “jsonp-polling” &gt;jsonp-polling &lt;/ option&gt; &lt;option value= “xhr-streaming” &gt;xhr-streaming &lt;/ option&gt; &lt;option value= “iframe-eventsource” &gt;iframe– eventsource&lt;/ option &gt; &lt;option value= “iframe-htmlfile” &gt;iframe– htmlfile&lt;/ option &gt; &lt;/ select&gt; &lt;/div &gt; &lt;div &gt; &lt;button id = “connect” onclick =“connect();” &gt;Connect &lt;/ button&gt; &lt;button id = “disconnect” disabled= “disabled” onclick =“disconnect();” &gt;Disconnect &lt;/ button&gt; &lt;/div &gt; &lt;div &gt; &lt;textarea id = “message” style=” width: 350px“ &gt;Here is a message!&lt;/ textarea&gt; &lt;/div &gt; &lt;div &gt; &lt;button id = “echo” onclick= “echo();” disabled =“disabled” &gt;Echo message &lt;/ button&gt; &lt;/div &gt; &lt;/div &gt; &lt;div id = “console-container”&gt; &lt;div id = “console”&gt;&lt;/ div&gt; &lt;/div&gt;&lt;/ div&gt;&lt;/ body&gt;&lt;/ html&gt; 注：最后只要注意你定义的springmvc拦截的路径规则和请求路径即可，我一开始总是报404错误，就是路径写错了。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phonegap jQueryMobile 在线应用拍照、相册选择上传+预览]]></title>
    <url>%2F2015%2F07%2F07%2FPhonegap-jQueryMobile-%E5%9C%A8%E7%BA%BF%E5%BA%94%E7%94%A8%E6%8B%8D%E7%85%A7%E3%80%81%E7%9B%B8%E5%86%8C%E9%80%89%E6%8B%A9%E4%B8%8A%E4%BC%A0-%E9%A2%84%E8%A7%88%2F</url>
    <content type="text"><![CDATA[拍照上传以及从相册中选择图片上传是大多数手机应用的典型功能，这几天在做一个移动端的项目，其中就用到该功能。 项目技术选择的是Phonegap+jQueryMobile，因为jQuery自己比较熟悉，用jQueryMobile没有什么大的难点。 界面用jQueryMobile搭的很快，一开始打算用Phonegap将应用做为离线版本，但后来发现离线版本升级的话还是和普通的app一样，都需要重新安装，这就没有了WebApp的优势和亮点，故最终选择了在线版本，即将项目作为一个web应用，用Tomcat发布在服务器上，Phonegap作为一个app外壳行使浏览器功能在其中请求服务器上的页面等资源。 做该功能的时候，由于对于Phonegap接触不久，花了我整整两天的时间，这两天没有做其他的，一直在研究如何实现图片预览，网上、官网有很多成功的例子，但没有一个在我这边成功预览的，几乎看遍了网上所有的帖子，点坏了鼠标！心情坏到了极点，因为本以为很简单的东西，而后网上说的也都很简单，很多帖子都是一样的内容，但是我却死活跑不通，崩溃！ 到最后，才发现问题原来出在我的“在线”应用上，无语，其实做J2EE的我深知浏览器端是无权限操作本地文件的，但是由于对Phonegap的不了解，由于知道Phonegap可以直接操作本地资源，误认为用了Phonegap就无敌了，你以为呢！于是我就把WebApp整成离线的试下喽，果然，可以显示了！ 但项目已经做到这个地步了，再把它重构成离线的？不可取。于是我就开始分析了。。。 Phonegap不是可以操作本地文件吗？html中的img标签不能根据本地图片路径渲染图片，但它可以不用文件路径啊！于是呵呵了。 最终解决方案是用Phonegap的FileReader来根据本地图片路径以base64的形式读取其内容，base64是可以直接在img标签上渲染的，所以问题就解决了。 下面截取拍照上传以及预览的代码如下： 图片处理代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144var picUrl = "" ;function capturePhotoUrl() &#123; navigator.camera.getPicture(onCaptureSuccess, onUrlFail, &#123; quality : 80,// allowEdit : true,//在Android中此配置忽略 destinationType : Camera.DestinationType.FILE_URI, sourceType:Camera.PictureSourceType.CAMERA, targetWidth : 800, // 生成的图片大小 单位像素 targetHeight : 640 &#125;); &#125;function onCaptureSuccess(imageURI) &#123; picUrl = imageURI; //这是关键部分 window.resolveLocalFileSystemURI(imageURI, function(fileEntry)&#123; fileEntry.file( function(file)&#123; var reader = new FileReader(); reader.onloadend = function(evt) &#123; $( "#uploadImgDom").append("&lt;img path='"+imageURI+"' class='uploadImg' src='"+evt.target.result+"' /&gt;"); $( "#report-page").trigger("create" ); &#125;; reader.readAsDataURL(file); &#125;, readFileFail); &#125;, readFileFail);// $("#urlinfo").text("图片的原始路径" + imageURI);&#125; function readFileFail(evt)&#123; navigator.notification.alert( "文件读取失败，原因：" + evt.code, null, "警告" );&#125; function onUrlFail(message) &#123; navigator.notification.alert( "失败，原因：" + message, null, "警告" );&#125; function loadImageLocal() &#123; navigator.camera.getPicture(onLoadSuccess, onUrlFail, &#123; quality : 80, sourceType : Camera.PictureSourceType.PHOTOLIBRARY, destinationType : Camera.DestinationType.FILE_URI,// encodingType : Camera.EncodingType.JPEG,// mediaType : Camera.MediaType.PICTURE, targetWidth : 800, // 生成的图片大小 单位像素，选择图片的时候一定要制定这个值，否则 targetHeight : 640 &#125;); &#125; function onLoadSuccess(imageURI) &#123; imageURI = imageURI + ".jpg"; picUrl = imageURI; window.resolveLocalFileSystemURI(imageURI, function(fileEntry)&#123; fileEntry.file( function(file)&#123; var reader = new FileReader(); reader.onloadend = function(evt) &#123; $( "#uploadImgDom").append("&lt;img path='"+imageURI+"' class='uploadImg' src='"+evt.target.result+"' /&gt;"); $( "#report-page").trigger("create" ); &#125;; reader.readAsDataURL(file); &#125;, readFileFail); &#125;, readFileFail);// $("#urlinfo").text("图片的原始路径" + picUrl);&#125; function uploadPhoto() &#123; $("#report-btn").attr(&#123; "disabled": "disabled"&#125;); var options = new FileUploadOptions(); options.fileKey = "file"; options.fileName = picUrl.substr(picUrl.lastIndexOf( '/') + 1); options.mimeType = "image/jpeg"; var ft = new FileTransfer(); //文件上传类 ft.onprogress = function (progressEvt) &#123; //显示上传进度条 if (progressEvt.lengthComputable) &#123; navigator.notification.progressValue(Math.round(( progressEvt.loaded / progressEvt.total ) * 100)); &#125; &#125; navigator.notification.progressStart( "提醒", "当前上传进度" ); var params = new Object(); params.title = $( "#textinput-2").val(); params.info = $( "#textarea-2").val(); params.longitude = $( "#longitude").text(); params.latitude = $( "#latitude").text(); options.params = params; ft.upload(picUrl, basePath+ "/report", win, fail, options);&#125; function win(r) &#123; navigator.notification.progressStop(); //停止进度条 $("#returnpic").attr( "src", basePath+ "/files/" + r.response); // $("#returninfo").html(// "上传成功\n：反馈的信息:r.responseCode:" + r.responseCode + "\nr.response:"// + r.response + "\nr.bytesSent:" + r.bytesSent); $("#report-btn").removeAttr( "disabled"); navigator.notification.alert( "上传成功！" , function()&#123; $( "#reportPageBackBtn").click(); &#125;, "提醒");&#125; function fail(error) &#123; /* * FileTransferError.FILE_NOT_FOUND_ERR：1 文件未找到错误。 * •FileTransferError.INVALID_URL_ERR：2 无效的URL错误。 * •FileTransferError.CONNECTION_ERR：3 连接错误。 FileTransferError.ABORT_ERR = * 4; 程序异常 */ var errorcode = error.code; var errstr = ""; switch (errorcode) &#123; case 1: &#123; errstr = "错误代码1：源文件路径异常，请重新选择或者拍照上传！" ; break; &#125; case 2: &#123; errstr = "错误代码2:目标地址无效,请重试！" ; break; &#125; case 3: &#123; errstr = "您手机或者后台服务器网络异常,请重新上传！" ; break; &#125; default: &#123; errstr = "程序出错"; break; &#125; &#125; $("#returninfo").text( "上传失败,错误代码:" + errstr + "上传源文件:" + error.source + "目标地址:" + error.target + "请重新上传！" ); $("#report-btn").removeAttr( "disabled");&#125; 前台显示代码：1234567891011&lt;div role= "main" class = "ui-content jqm-content" data-iscroll ="content" &gt; &lt;div class = "ui-grid-a"&gt; &lt;div class = "ui-block-a"&gt; &lt;a href = "#" onclick ="capturePhoto()" class = "ui-shadow ui-btn ui-btn-b ui-corner-all ui-btn-icon-left ui-icon-camera"&gt; 拍照&lt;/ a&gt; &lt;/div&gt; &lt;div class = "ui-block-b"&gt; &lt;a href = "#" onclick ="loadImageLocal()" class= "ui-shadow ui-btn ui-btn-b ui-corner-all ui-btn-icon-left ui-icon-heart"&gt; 相册&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id = "returninfo"&gt;&lt;/div&gt;&lt;div id = "uploadImgDom"&gt;&lt;/div&gt; 后台上传的代码就不贴了，就一个Servlet。 谨记我这两天的精彩编程生活。 最后感谢所有网友的帮助与分享！]]></content>
      <tags>
        <tag>WebApp</tag>
      </tags>
  </entry>
</search>
